
import json
import cv2
import numpy as np
import os
import sys

# Add current directory to path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

import ds_camera_cv
from ds_camera import DoubleSphereCamera

def load_config(config_path):
    with open(config_path, 'r') as f:
        return json.load(f)

def verify_projection(K, D, K_new, w, h, name):
    print(f"\n--- Verifying {name} ---")
    
    # 1. Generate grid of pixels in Undistorted Image
    # We take a sparse grid to be fast
    step = 50
    y_grid, x_grid = np.mgrid[0:h:step, 0:w:step]
    points_undist = np.stack([x_grid, y_grid], axis=-1).reshape(-1, 2).astype(np.float64)
    
    # 2. Unproject using K_new inverse (Pinhole Model)
    # [x, y, 1]^T = K_new^-1 * [u, v, 1]^T
    # Ray direction d = (x, y, 1) / norm
    
    fx_new, fy_new = K_new[0, 0], K_new[1, 1]
    cx_new, cy_new = K_new[0, 2], K_new[1, 2]
    
    mx = (points_undist[:, 0] - cx_new) / fx_new
    my = (points_undist[:, 1] - cy_new) / fy_new
    mz = np.ones_like(mx)
    
    rays_pinhole = np.stack([mx, my, mz], axis=-1)
    rays_pinhole = rays_pinhole / np.linalg.norm(rays_pinhole, axis=-1, keepdims=True)
    
    # 3. Project these rays using Double Sphere Model to Distorted Image
    cam = DoubleSphereCamera(K[0,0], K[1,1], K[0,2], K[1,2], D[0], D[1], w, h)
    points_dist_projected, valid_projected = cam.project(rays_pinhole)
    
    # 4. Compare with Ground Truth Mapping
    # The ground truth mapping is what cv2.remap uses.
    # We can compute the map directly using initUndistortRectifyMap logic
    # mapx, mapy = ds_camera_cv.initUndistortRectifyMap(...)
    # But that function does exactly what we did in step 2 & 3 internally!
    # So we are verifying that the "K-inverse" logic matches the "Undistortion Map" logic.
    
    # Let's verify against the map generated by ds_camera_cv
    mapx, mapy = ds_camera_cv.initUndistortRectifyMap(K, D, None, K_new, (w, h), cv2.CV_32FC1)
    
    # Sample map at the grid points
    # mapx[v, u] gives the distorted x coordinate for undistorted pixel (u, v)
    
    points_undist_int = points_undist.astype(int)
    gt_dist_x = mapx[points_undist_int[:, 1], points_undist_int[:, 0]]
    gt_dist_y = mapy[points_undist_int[:, 1], points_undist_int[:, 0]]
    points_dist_gt = np.stack([gt_dist_x, gt_dist_y], axis=-1)
    
    # Calculate error
    # Only consider points that are valid in the projection
    # And points where the map is not -1 (invalid mapping)
    # Note: initUndistortRectifyMap doesn't set invalid to -1, it just extrapolates or something.
    # But our cam.project returns a valid mask.
    
    diff = np.linalg.norm(points_dist_projected - points_dist_gt, axis=1)
    
    # Filter valid
    # We only care about pixels that actually map to something valid in the distorted image
    valid_mask = valid_projected
    
    mean_error = diff[valid_mask].mean()
    max_error = diff[valid_mask].max()
    
    print(f"Mean Reprojection Error: {mean_error:.6f} pixels")
    print(f"Max Reprojection Error: {max_error:.6f} pixels")
    
    if mean_error < 0.1:
        print("✅ Verification Successful: K^-1 unprojection matches DS distortion.")
    else:
        print("❌ Verification Failed: Significant discrepancy found.")

def main():
    config_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'test_config.json')
    config = load_config(config_path)
    
    intr = config['intrinsics']
    K = np.array([[intr['fx'], 0, intr['cx']], [0, intr['fy'], intr['cy']], [0, 0, 1]])
    D = np.array([intr['xi'], intr['alpha']])
    w, h = intr['width'], intr['height']
    
    # 1. Optimal Crop
    K_new_crop = ds_camera_cv.estimateNewCameraMatrixForUndistortRectify(K, D, (w, h), balance=1.0)
    verify_projection(K, D, K_new_crop, w, h, "Optimal Crop (balance=1.0)")
    
    # 2. Keep Whole
    K_new_whole = ds_camera_cv.estimateNewCameraMatrixForUndistortRectify(K, D, (w, h), balance=0.0)
    verify_projection(K, D, K_new_whole, w, h, "Keep Whole (balance=0.0)")
    
    # 3. Zoom Out
    K_new_zoom = K_new_whole.copy()
    K_new_zoom[0, 0] /= 4.0
    K_new_zoom[1, 1] /= 4.0
    K_new_zoom[0, 2] = w / 2.0
    K_new_zoom[1, 2] = h / 2.0
    verify_projection(K, D, K_new_zoom, w, h, "Zoom Out (4x)")

if __name__ == "__main__":
    main()
